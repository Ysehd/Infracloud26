In dit experiment, DI2 – Eigen Docker image, heb ik aangetoond dat ik zelf een Docker image kan bouwen en deze als container kan uitvoeren. Ik heb hiervoor een eenvoudige Flask-webapplicatie gebruikt. Die applicatie staat in het bestand myapp.py en doet eigenlijk maar één ding: ze toont een webpagina wanneer je naar de root-URL gaat. In de code initialiseert Flask eerst de applicatie en daarna wordt een route gedefinieerd voor / die een HTML-template rendert. Onderaan start de applicatie met app.run(host="0.0.0.0", port=8080). Dat 0.0.0.0 is belangrijk omdat de applicatie anders alleen binnen de container bereikbaar zou zijn en niet vanaf de host. De poort 8080 is gekozen omdat die later ook in Docker wordt gebruikt.

Om van die applicatie een container te maken, heb ik een Dockerfile gebruikt. Die Dockerfile is gebaseerd op een lichte Python-image, namelijk python:3.8-slim. In de Dockerfile wordt eerst Flask geïnstalleerd, daarna wordt een werkdirectory aangemaakt in de container en worden het Python-script, de templates en de statische bestanden gekopieerd. Vervolgens wordt poort 8080 geëxposed en wordt vastgelegd dat bij het starten van de container automatisch het Python-script wordt uitgevoerd. Daardoor start de Flask-app vanzelf wanneer de container draait.

Voor het bouwen en starten van de container heb ik een Bash-script geschreven. Dat script ruimt eerst eventuele oude containers op zodat er geen conflicten zijn. Daarna maakt het een tijdelijke map aan die dient als build-context voor Docker en kopieert het alle nodige bestanden naar die map. In diezelfde map wordt automatisch een Dockerfile aangemaakt. Vervolgens wordt met docker build een eigen Docker image aangemaakt en met docker run wordt een container gestart waarbij poort 8080 van de container gemapt wordt naar poort 8080 van de host. Op die manier is de webapplicatie bereikbaar via de browser op http://localhost:8080.

Als alles correct loopt, draait de container zonder fouten en kan ik in de browser de webpagina zien. Met docker ps kan ik controleren of de container effectief actief is. Dit experiment toont aan dat ik begrijp hoe een Docker image wordt opgebouwd, hoe een applicatie correct in een container moet draaien en hoe poortmapping werkt. Het verschil met DC1 is dat ik hier zelf het image bouw in plaats van een bestaand image te gebruiken. Daarmee voldoet dit experiment volledig aan de vereisten van DI2.